class SituacionDeRebase

types
  public avisoConductorTipos = <Muy_riesgoso> | <Riesgoso> | <Aceptado> | <Sin_riesgo>;
  public datosCarro :: latitud : real longitud : real velocidad : real;
  public autosRegister :: autoAtras: Auto
                              autoMedio: Auto
                              autoFrente: Auto;

  

instance variables
  autos: autosRegister;
  terrenoCarretera: Carretera;
  avisoAutoAtras: avisoConductorTipos;
  avisoAutoMedio: avisoConductorTipos;
  avisoAutoFrente: avisoConductorTipos;
  isActualizado : bool;
  timepoUltimaActualizacion : real; -- en milisegundos.

inv autos.autoAtras <> autos.autoMedio and autos.autoAtras <> autos.autoFrente and autos.autoMedio <> autos.autoFrente;
-- inv ObtenerdistanciaAtrasMedio() >= 0 and ObtenerdistanciaAtrasDelante() >= 0 and ObtenerdistanciaMedioDelante() >= 0;
operations

  -- Constructor para crear una nueva situación de rebase con los autos y la carretera proporcionados
  public SituacionDeRebase: Auto * Auto * Auto * Carretera ==> SituacionDeRebase
  SituacionDeRebase(autoAtras, autoMedio, autoFrente, carretera) ==
    (
      autos := mk_autosRegister(autoAtras, autoMedio, autoFrente);
      terrenoCarretera := carretera;
      avisoAutoAtras := <Sin_riesgo>;
      avisoAutoMedio := <Sin_riesgo>;
      avisoAutoFrente := <Sin_riesgo>;
      return self;
    );
  -- Método para actualizar la situación con las nuevas posiciones y velocidades de los autos
  public actualizarSituacion : datosCarro * datosCarro * datosCarro * real ==> ()
  actualizarSituacion(carroAtrasNuevoDato, carroMedioNuevoDato, carroFrenteNuevoDato, tiempoTranscurrido) ==
    (
      autos.autoAtras.setUbicacion(carroAtrasNuevoDato.latitud, carroAtrasNuevoDato.longitud);
      autos.autoAtras.setVelocidad(carroAtrasNuevoDato.velocidad);
      
      autos.autoMedio.setUbicacion(carroMedioNuevoDato.latitud, carroMedioNuevoDato.longitud);
      autos.autoMedio.setVelocidad(carroMedioNuevoDato.velocidad);

      autos.autoFrente.setUbicacion(carroFrenteNuevoDato.latitud, carroFrenteNuevoDato.longitud);
      autos.autoFrente.setVelocidad(carroFrenteNuevoDato.velocidad);

      timepoUltimaActualizacion := tiempoTranscurrido;
      isActualizado := true;
      
    );


  -- Método para obtener la distancia entre el auto de atrás y el auto del medio
  public ObtenerdistanciaAtrasMedio: () ==> real
  ObtenerdistanciaAtrasMedio() == (
      let 
        lat1 : real = autos.autoAtras.getUbicacion().latitud,
        lon1 : real = autos.autoAtras.getUbicacion().longitud,
        lat2 : real = autos.autoMedio.getUbicacion().latitud,
        lon2 : real = autos.autoMedio.getUbicacion().longitud
      in
        return terrenoCarretera.getDistanciaPuntos(lat1, lon1, lat2, lon2);
  );

  -- Método para obtener la distancia entre el auto de atrás y el auto de adelante
  public ObtenerdistanciaAtrasFrente: () ==> real
  ObtenerdistanciaAtrasFrente() ==
    let 
      lat1 : real = autos.autoAtras.getUbicacion().latitud,
      lon1 : real = autos.autoAtras.getUbicacion().longitud,
      lat2 : real = autos.autoFrente.getUbicacion().latitud,
      lon2 : real = autos.autoFrente.getUbicacion().longitud
    in
      return terrenoCarretera.getDistanciaPuntos(lat1, lon1, lat2, lon2);
    
  -- Método para obtener la distancia entre el auto del medio y el auto de adelante
  public ObtenerdistanciaMedioDelante: () ==> real
  ObtenerdistanciaMedioDelante() ==
   let 
      lat1 : real = autos.autoMedio.getUbicacion().latitud,
      lon1 : real = autos.autoMedio.getUbicacion().longitud,
      lat2 : real = autos.autoFrente.getUbicacion().latitud,
      lon2 : real = autos.autoFrente.getUbicacion().longitud
    in
      return terrenoCarretera.getDistanciaPuntos(lat1, lon1, lat2, lon2);

  -- Método para obtener el tiempo necesario para que el auto de atrás alcance al auto de adelante
  public ObtenerTiempoAtrasFrente: () ==> real
  ObtenerTiempoAtrasFrente() == (
    let 
      auto1 = autos.autoAtras,
      auto2 = autos.autoFrente,

      solve : EcuacionCuadratica = new EcuacionCuadratica(),
      a1 = auto1.calcularAceleracion(timepoUltimaActualizacion),
      a2 = auto2.calcularAceleracion(timepoUltimaActualizacion),

      v1 = auto1.getVelocidad(),
      v2 = auto2.getVelocidad(),

      lat1 = auto1.getUbicacion().latitud,
      lon1 = auto1.getUbicacion().longitud,
      lat2 = auto2.getUbicacion().latitud,
      lon2 = auto2.getUbicacion().longitud,

      d = terrenoCarretera.getDistanciaPuntos(lat1,lon1,lat2, lon2),

      -- valores para resolver la ecu.
      a = (a1 + a2) /2,
      b = v1 + v2,
      c = -d

    in

      return solve.calcularRaices(a, b, c).getPositivo();
  )
  pre isActualizado = true;
  
  -- Método para obtener el tiempo necesario para que el auto del medio alcance al auto de adelante
  public ObtenerTiempoMedioDelante: () ==> real
  ObtenerTiempoMedioDelante() == (
    let 
      auto1 = autos.autoMedio,
      auto2 = autos.autoFrente,

      solve : EcuacionCuadratica = new EcuacionCuadratica(),
      a1 = auto1.calcularAceleracion(timepoUltimaActualizacion),
      a2 = auto2.calcularAceleracion(timepoUltimaActualizacion),

      v1 = auto1.getVelocidad(),
      v2 = auto2.getVelocidad(),

      lat1 = auto1.getUbicacion().latitud,
      lon1 = auto1.getUbicacion().longitud,
      lat2 = auto2.getUbicacion().latitud,
      lon2 = auto2.getUbicacion().longitud,

      d = terrenoCarretera.getDistanciaPuntos(lat1,lon1,lat2, lon2),

      -- valores para resolver la ecu.
      a = (a1 + a2) /2,
      b = v1 + v2,
      c = -d

    in

      return solve.calcularRaices(a, b, c).getPositivo();
  )
  pre isActualizado = true;

 -- Método para obtener el tiempo necesario para que el auto del medio alcance al auto de adelante
  public ObtenerTiempoAtrasMedio: () ==> real
  ObtenerTiempoAtrasMedio() == (
    let 
      auto1 = autos.autoAtras,
      auto2 = autos.autoMedio,

      solve : EcuacionCuadratica = new EcuacionCuadratica(),
      a1 = auto1.calcularAceleracion(timepoUltimaActualizacion),
      a2 = auto2.calcularAceleracion(timepoUltimaActualizacion),

      v1 = auto1.getVelocidad(),
      v2 = auto2.getVelocidad(),

      lat1 = auto1.getUbicacion().latitud,
      lon1 = auto1.getUbicacion().longitud,
      lat2 = auto2.getUbicacion().latitud,
      lon2 = auto2.getUbicacion().longitud,

      d = terrenoCarretera.getDistanciaPuntos(lat1,lon1,lat2, lon2),

      -- valores para resolver la ecu.
      a = (a1 - a2) /2,
      b = v1 - v2,
      c = -d

    in

      return solve.calcularRaices(a, b, c).getPositivo();
  )
  pre isActualizado = true;

  -- Método para calcular el riesgo de colisión
  public CalcularRiesgoDeColision: () ==> real
  CalcularRiesgoDeColision() ==
    -- Implementa la lógica para calcular el riesgo
    return 0;  -- Modificar según la lógica real


  -- Método para enviar un aviso al conductor del auto proporcionado
  public AvisoAlConductor: Auto ==> seq of char
  AvisoAlConductor(auto) ==
    -- Implementa la lógica para enviar un aviso al conductor
    return "Aviso al conductor";  -- Modificar según la lógica real

  -- Método para obtener el auto de atrás
  public GetCarroAtras: () ==> Auto
  GetCarroAtras() ==
    return autos.autoAtras;

  -- Método para obtener el auto del medio
  public GetCarroMedio: () ==> Auto
  GetCarroMedio() ==
    return autos.autoMedio;

  -- Método para obtener el auto de adelante
  public GetCarroAdelante: () ==> Auto
  GetCarroAdelante() ==
    return autos.autoFrente;
end SituacionDeRebase
